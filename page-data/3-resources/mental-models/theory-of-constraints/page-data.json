{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/3-resources/mental-models/theory-of-constraints","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Theory of Constraints\"), mdx(\"p\", null, \"The core concept of the Theory of Constraints is that every process has a single constraint and that total process throughput can only be improved when the constraint is improved. A very important corollary to this is that spending time optimizing non-constraints will not provide significant benefits; only improvements to the constraint will further the goal (achieving more profit).\"), mdx(\"p\", null, \"Thus, TOC seeks to provide precise and sustained focus on improving the current constraint until it no longer limits throughput, at which point the focus moves to the next constraint. The underlying power of TOC flows from its ability to generate a tremendously strong focus towards a single goal (profit) and to removing the principal impediment (the constraint) to achieving more of that goal.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"tableOfContents":{"items":[{"url":"#theory-of-constraints","title":"Theory of Constraints"}]},"outboundReferences":[],"inboundReferences":[{"contextLine":"> Any improvement made after the bottleneck is useless, because it will always remain starved, waiting for work from the bottleneck. And any improvements made before the bottleneck merely results in more inventory piling up at the bottleneck. [[theory-of-constraints]]","referrer":{"parent":{"id":"c209e89b-969e-5815-9674-0457f93c32bb","fields":{"slug":"/3-resources/books/The-Phoenix-Project","title":"The Phoenix Project"}}}}]},"fields":{"slug":"/3-resources/mental-models/theory-of-constraints","title":"Theory of Constraints"}}},"pageContext":{"id":"4c4071a3-a22c-58e4-a7cf-4394de4c5849","refWordMdxSlugDict":{},"tocTypes":["sidebar"]}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}